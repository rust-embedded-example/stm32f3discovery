# 环境搭建

本教程使用ubuntu操作系统，虚拟机也是可以的。若不会科学上网，可以询问AI，设置国内镜像源，包括ubuntu使用的国内镜像与Rust使用的国内镜像。

## 安装Rust

访问 [Rust 官方网站](https://www.rust-lang.org/)，点击最上方的`Install`，查看安装教程，进行安装。

## 安装交叉编译器

我们需要在 Linux 操作系统下为 stm32f3x 系列芯片编译程序，这需要为 Rust 开发环境添加交叉编译能力。对于 stm32f3x 芯片，其对应的目标三元组（target triple）是 `thumbv7em-none-eabihf`。

使用以下命令通过 `rustup` 安装：

```bash
rustup target add `thumbv7em-none-eabihf`
```

这个看起来很复杂的目标名称可以分解为以下几个部分：

* **`thumb`**: 指的是 ARM 处理器的 **Thumb-2** 指令集。这是一个 16/32 位混合指令集，旨在提高代码密度，减少内存占用，非常适用于资源受限的嵌入式系统。

* **`v7em`**: 指的是 ARM 架构的特定版本。
  * `v7` 表示 **ARMv7** 架构。
  * `em` 表示这是一个高性能的嵌入式配置文件，支持 DSP (数字信号处理) 扩展和单精度浮点单元 (FPU)。这个目标通常用于 ARM Cortex-M4F 和 ARM Cortex-M7F 处理器。

* **`none`**: 表示这是一个 **裸机 (bare-metal)** 目标。这意味着编译出的程序不依赖任何操作系统（如 Linux 或 FreeRTOS），而是直接在硬件上运行。

* **`eabi`**: 代表 **嵌入式应用二进制接口 (Embedded Application Binary Interface)**。ABI 定义了二进制代码之间如何交互的规则，例如：
  * 函数调用约定（如何传递参数、返回值）
  * 数据类型的大小和对齐方式
  * 寄存器的使用
  * 可执行文件格式
  
  EABI 专为嵌入式系统设计，针对有限资源进行了优化。

* **`hf`**: 代表 **硬浮点 (Hard Float)**。这表示 ABI 假定目标处理器具有硬件浮点单元 (FPU)。浮点运算将由 FPU 直接处理，而不是通过软件模拟，从而带来显著的性能提升。

### 交叉编译器解释

想象一下：

* 编译器就像一个工厂，负责把你的源代码（比如 Rust 代码）转换成可执行的程序。
* `thumbv7em-none-eabihf` 就像工厂里的一张产品规格单，上面详细写明了：
  * "这个产品是要给 ARM Cortex-M4F/M7F 处理器用的。"
  * "它不能依赖任何操作系统，直接在硬件上跑。"
  * "它要用那种节省空间的 Thumb 指令。"
  * "而且这个处理器有硬件浮点运算能力，所以请用最快的方式来处理浮点数。"

这就像你买了一个专门做某种菜的厨具套装。你的大厨房（Rust 编译器）本身很强大，能做很多菜，但要做出特定风味的菜（比如针对嵌入式设备的程序），你就需要额外的专门工具。

### 安装交叉工具链的原因

安装支持 `thumbv7em-none-eabihf` 的工具链组件主要有以下几个原因：

1. **特定目标的代码生成**：你的计算机（比如 Windows、macOS 或 Linux）使用的处理器架构和操作系统与嵌入式设备完全不同。为了让 Rust 编译器能够生成能在 ARM Cortex-M 微控制器上运行的机器码，它需要知道该目标平台的指令集、内存布局、调用约定等等。安装对应的工具链组件，就是给编译器提供了这些特定的"编译规则"。

2. **交叉编译能力**：你在自己的电脑上编写和编译代码，但目标程序是要在另一个不同的平台上运行。这种行为叫做交叉编译（Cross-Compiling）。为了实现这一点，Rust 需要针对目标平台的特定编译器后端、链接器和其他工具。

3. **标准库支持**：虽然 none 表示裸机环境没有操作系统，但 Rust 的核心库（core 和 alloc）仍然需要针对这个特定的裸机目标进行编译和优化。安装目标组件会确保你有这些库的正确版本。

4. **rustup 的管理**：rustup 是 Rust 官方的工具链管理器。它允许你在同一台机器上管理多个 Rust 版本和多个目标支持。当你执行 `rustup target add thumbv7em-none-eabihf` 命令时，rustup 会自动下载和配置所有必要的组件，以便你的 Rust 编译器能够针对这个目标进行编译。